---
import { ClientRouter } from 'astro:transitions';
import { Scanlines } from '../components/Scanlines';
import { TerminalHeader } from '../components/TerminalHeader';
import { TerminalFooter } from '../components/TerminalFooter';
import Navbar from '../components/Navbar.astro';
import { MinimizedComponents } from '../components/MinimizedComponents';
import { FullComponents } from '../components/FullComponents';
import '../styles/global.css';

interface Props {
	title?: string;
}

const { title = 'Terminal Scope' } = Astro.props;
const pathname = Astro.url.pathname;

// Calculate "command prompt" based on path
let command = 'echo "Hello World"';
if (pathname === '/') command = 'cat ~/dashboard.md';
else if (pathname.startsWith('/blog')) command = 'ls -l ~/blog';
else if (pathname.startsWith('/resources')) command = 'find ~/resources -type f';
else if (pathname === '/about') command = 'whoami';

// Parse breadcrumb path for clickable links
function getBreadcrumbPath() {
	if (pathname === '/') return { segments: [], currentPath: '/' };
	
	const segments = pathname.split('/').filter(Boolean);
	const currentPath = '/' + segments.join('/');
	return { segments, currentPath };
}

const { segments } = getBreadcrumbPath();

---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Astro description" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
        <ClientRouter />
	</head>
	<body>
        <Scanlines client:load />
        
        <main id="terminal-main" class="w-full max-w-5xl relative z-10 flex flex-col shadow-2xl overflow-hidden md:rounded-lg md:border-2 bg-bg border-surface h-[90vh] min-h-[600px] mx-auto mt-0 md:mt-8">
            <div class="flex items-center border-b bg-surface border-bg h-10">
                <TerminalHeader client:load />
                <MinimizedComponents client:load />
            </div>
            
            <div class="flex-1 overflow-y-auto p-4 md:p-8 relative scrollbar-thin scrollbar-thumb-surface scrollbar-track-transparent">
                <Navbar />
                
                {/* Fake Command Prompt */}
                <div class="mb-6 font-mono text-sm md:text-base h-8 flex items-center flex-wrap">
                     <a href="/" class="text-success hover:text-accent transition-colors cursor-pointer">visitor@site</a>
                     <span class="mx-1 opacity-50">:</span>
                     <span class="text-link">
                         {pathname === '/' ? (
                             <span>~</span>
                         ) : (
                             <>
                                 <a href="/" class="hover:text-accent transition-colors cursor-pointer">~</a>
                                 {segments.map((segment, index) => {
                                     const segmentPath = '/' + segments.slice(0, index + 1).join('/');
                                     const isLast = index === segments.length - 1;
                                     return (
                                         <>
                                             <span class="opacity-50">/</span>
                                             {isLast ? (
                                                 <span>{segment}</span>
                                             ) : (
                                                 <a href={segmentPath} class="hover:text-accent transition-colors cursor-pointer">{segment}</a>
                                             )}
                                         </>
                                     );
                                 })}
                             </>
                         )}
                     </span>
                     <span class="mx-1 opacity-50">$</span>
                     <span>{command}</span>
                     <span class="inline-block w-2 h-4 bg-text animate-pulse align-middle ml-1"></span>
                </div>

                <div class="animate-fade-in min-h-[400px]">
		            <slot />
                </div>
            </div>

            <TerminalFooter client:load />
            <FullComponents client:load />
        </main>
        <script>
            // Sync maximize state from body to main element on every page
            const initMaximizeSync = () => {
                const main = document.getElementById('terminal-main');
                if (!main) return;

                const applyState = () => {
                    const isMaximized = document.body.getAttribute('data-maximized') === 'true';
                    if (isMaximized) {
                        main.setAttribute('data-maximized', 'true');
                    } else {
                        main.removeAttribute('data-maximized');
                    }
                };

                applyState();

                if (main.__maximizeObserver) {
                    main.__maximizeObserver.disconnect();
                }

                const observer = new MutationObserver(applyState);
                observer.observe(document.body, { attributes: true, attributeFilter: ['data-maximized'] });
                main.__maximizeObserver = observer;
            };

            document.addEventListener('DOMContentLoaded', initMaximizeSync);
            document.addEventListener('astro:page-load', initMaximizeSync);
        </script>
        <script>
            // Monitor YouTube iframes and pause radio when videos start playing
            (function() {
                let youtubePlayers = new Map();
                let messageHandlers = new Map();
                let isYouTubeAPILoaded = false;

                function loadYouTubeAPI() {
                    if (isYouTubeAPILoaded || document.querySelector('script[src*="youtube.com/iframe_api"]')) return;
                    
                    const tag = document.createElement('script');
                    tag.src = 'https://www.youtube.com/iframe_api';
                    const firstScriptTag = document.getElementsByTagName('script')[0];
                    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                    isYouTubeAPILoaded = true;
                }

                function findYouTubeIframes() {
                    return document.querySelectorAll('iframe[src*="youtube"], iframe[src*="youtu.be"]');
                }

                function initYouTubePlayer(iframe) {
                    if (youtubePlayers.has(iframe)) return;

                    // Use YouTube iframe API if available
                    if (window.YT && window.YT.Player) {
                        try {
                            const player = new window.YT.Player(iframe, {
                                events: {
                                    onStateChange: function(event) {
                                        // State 1 = playing
                                        if (event.data === 1) {
                                            window.dispatchEvent(new CustomEvent('youtube-video-playing'));
                                        }
                                    }
                                }
                            });
                            youtubePlayers.set(iframe, player);
                        } catch (e) {
                            console.warn('Could not initialize YouTube player:', e);
                            setupPostMessageFallback(iframe);
                        }
                    } else {
                        setupPostMessageFallback(iframe);
                    }
                }

                function setupPostMessageFallback(iframe) {
                    if (messageHandlers.has(iframe)) return;

                    const messageHandler = (event) => {
                        // Check if message is from this iframe
                        if (event.source !== iframe.contentWindow) return;
                        
                        try {
                            if (typeof event.data === 'string') {
                                const data = JSON.parse(event.data);
                                // YouTube iframe API sends state change events
                                if (data.event === 'onStateChange' && data.info === 1) {
                                    window.dispatchEvent(new CustomEvent('youtube-video-playing'));
                                }
                            }
                        } catch (e) {
                            // Not a YouTube message, ignore
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    messageHandlers.set(iframe, messageHandler);
                }

                function monitorYouTubeIframes() {
                    const iframes = findYouTubeIframes();
                    iframes.forEach(iframe => {
                        if (!youtubePlayers.has(iframe) && !messageHandlers.has(iframe)) {
                            initYouTubePlayer(iframe);
                        }
                    });
                }

                // Global message listener for YouTube postMessage events
                function setupGlobalMessageListener() {
                    window.addEventListener('message', (event) => {
                        // Check if message is from YouTube
                        if (event.origin !== 'https://www.youtube.com' && 
                            event.origin !== 'https://www.youtube-nocookie.com') {
                            return;
                        }

                        try {
                            if (typeof event.data === 'string') {
                                const data = JSON.parse(event.data);
                                if (data.event === 'onStateChange' && data.info === 1) {
                                    window.dispatchEvent(new CustomEvent('youtube-video-playing'));
                                }
                            }
                        } catch (e) {
                            // Not a YouTube message, ignore
                        }
                    });
                }

                // Initialize on page load
                function init() {
                    setupGlobalMessageListener();
                    loadYouTubeAPI();
                    
                    // Wait for YouTube API to load
                    if (window.YT) {
                        window.YT.ready(monitorYouTubeIframes);
                    } else {
                        const originalReady = window.onYouTubeIframeAPIReady;
                        window.onYouTubeIframeAPIReady = function() {
                            if (originalReady) originalReady();
                            monitorYouTubeIframes();
                        };
                    }
                    
                    // Also monitor for new iframes
                    const observer = new MutationObserver(() => {
                        monitorYouTubeIframes();
                    });
                    
                    observer.observe(document.body, { childList: true, subtree: true });
                    monitorYouTubeIframes();
                }

                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', init);
                } else {
                    init();
                }

                // Re-initialize on Astro page transitions
                document.addEventListener('astro:page-load', () => {
                    youtubePlayers.clear();
                    messageHandlers.clear();
                    setTimeout(monitorYouTubeIframes, 500);
                });
            })();
        </script>
        <style>
            @media (min-width: 768px) {
                #terminal-main {
                    transition: none;
                }

                body[data-maximize-anim='true'] #terminal-main {
                    transition: all 0.3s ease;
                }

                #terminal-main[data-maximized='true'] {
                    position: fixed;
                    inset: 0;
                    max-width: none;
                    height: 100vh;
                    margin-top: 0;
                    border-radius: 0;
                }
            }
        </style>
	</body>
</html>

